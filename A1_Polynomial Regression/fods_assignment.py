# -*- coding: utf-8 -*-
"""FoDS Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hfriyzIJd9gvH75dv9P1wMoZJIY7ZyD2
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from collections import OrderedDict

def preprocess_data(data,standardize,deg):
  data.sample(frac=1)
  X_train = data[["Strength","Temperature"]][:1155]
  y_train = data["Pressure"][:1155]
  X_test =  data[["Strength","Temperature"]][1155:]
  y_test = data["Pressure"][1155:] 
  if(standardize==1):
      mn = X_train.mean()
      std = X_train.std()
      X_train = (X_train - mn)/std
      X_test = (X_test - mn)/std
      
  elif(standardize==0):
      mini = X_train.min()
      maxi = X_train.max()
      X_train = (X_train - mini)/(maxi-mini)
      X_test = (X_test - mini)/(maxi-mini)
      
 
  xt=pd.DataFrame([])
  xtst = pd.DataFrame([])
  pow = []
  for i in range(deg+1):
    for j in range(deg+1):
      if(i+j <= deg):
        pow.append((i,j))
  idx=0
  for (x,y) in pow:
    r1=((X_train["Strength"]**x)*(X_train["Temperature"]**y))
    r2=((X_test["Strength"]**x)*(X_test["Temperature"]**y))
    xt.insert(idx,"f"+str(x)+str(y),r1,True)
    xtst.insert(idx,"f"+str(x)+str(y),r2,True)
    idx+=1
  return xt,y_train,xtst,y_test,idx

data = pd.read_csv('/content/FoDS-A1.csv')

import math
def grad_desc(X,Y,Xt,Yt,lr,N,deg):
  X = np.array(X)
  Y = np.array(Y)
  Xt = np.array(Xt)
  Yt = np.array(Yt)
  prev=1e10
  W= np.random.random(N)
  min_e=math.inf
  min_et=math.inf
  for i in range(10000):
    d= ((X@W.T)-Y) 
    dt = ((Xt@W.T)-Yt)
    e = (0.5)*(d@d)
    et = (0.5)*(dt@dt)
    min_e = min(e,min_e)
    min_et = min(et,min_et)
    grad = (X.T@d)
    #if(i%50 == 0):
      #print("Epoch = ",i,"|| train_error = ",e/len(X),"||","test_error = ",et/len(Xt),"||",W)
    W -= lr*(grad/len(X))
    if(abs(prev-e) <= 5e-5):
      print("Breaking out of loop")
      break
    prev=e
  
  print("POLYNOMIAL OF DEGREE : " , deg)

  print("TRAIN ERROR : " , e)
  print("AVG. TRAIN ERROR : " , e/len(X))
  print("TEST ERROR : " , et)
  print("AVG. TEST ERROR : " , et/len(Xt))
  print("MIN. TRAIN ERROR : " , min_e/len(X))
  print("MIN. TEST ERROR : " , min_et/len(Xt))
  print("RMSE TRAIN : " , np.sqrt((2*min_e)/len(X)))
  print("RMSE TEST: " , np.sqrt((2*min_et)/len(Xt)))
  print("Weights : " , W)
  print("==================================================================")
  return e,e/len(X),et,et/len(Xt),min_e/len(X),min_et/len(Xt),W

def sgd(X,Y,Xt,Yt,lr,N,deg):
  X= np.array(X)
  Y = np.array(Y)
  Xt = np.array(Xt)
  Yt = np.array(Yt)
  W = np.random.random(N)
  min_e=math.inf
  min_et=math.inf
  prev=1e10
  for i in range(5000):
    d = ((X@W)-Y)
    dt = ((Xt@W)-Yt)
    if((0.5)*(d@d) == math.inf or (0.5)*(d@d) == math.nan):
      break
    e = (0.5)*(d@d)
    et = (0.5)*(dt@dt)
    min_e = min(e,min_e)
    min_et = min(et,min_et)
    for id in range(len(X)):
      W -= (lr)*(((X[id]@W.T)-Y[id])*X[id])
    #if(i%50==0):
      #print("Epoch = ",i,"|| train_error= ",e,"|| test_error= ",et,"|| ",W)
    if(abs(prev-e) <= 5e-5):
      break
    prev=e
  
  print("POLYNOMIAL OF DEGREE : " , deg)
  print("TRAIN ERROR : " , e)
  print("AVG. TRAIN ERROR : " , e/len(X))
  print("TEST ERROR : " , et)
  print("AVG. TEST ERROR : " , et/len(Xt))
  print("MIN. TRAIN ERROR : " , min_e/len(X))
  print("MIN. TEST ERROR : " , min_et/len(Xt))
  print("RMSE TRAIN : " , np.sqrt((2*min_e)/len(X)))
  print("RMSE TEST: " , np.sqrt((2*min_et)/len(Xt)))

  print("Weights : " , W)
  print("==================================================================")
  return e,e/len(X),et,et/len(Xt),min_e/len(X),min_et/len(Xt),W

w = dict()

mse_tr=[]
mse_tst=[]
degs=[]
result_gd = pd.DataFrame(columns=['Degree','Train Error','Avg Train Error','Test Error','Avg Test Error','Min Avg Train Error','Min Avg Test error','W'])
for deg in range(10):
  X_train,y_train,X_test,y_test,N=preprocess_data(data,0,deg)
  print("FITTING POLYNOMIAL OF DEGREE : " , deg)
  tr,atr,te,ate,mtr,mte,w[deg]=grad_desc(X_train,y_train,X_test,y_test,0.1,N,deg)
  result_gd=result_gd.append({'Degree':deg,'Train Error':tr,'Avg Train Error':atr,'Test Error':te,'Avg Test Error':ate,'Min Avg Train Error':mtr,'Min Avg Test error':mte,'W':w[deg]},ignore_index=True)
  mse_tr.append(mtr)
  mse_tst.append(mte)
  degs.append(deg)

X_train,y_train,X_test,y_test,N=preprocess_data(data,0,7)
tr,atr,te,ate,mtr,mte,w[7]=grad_desc(X_train,y_train,X_test,y_test,0.001,N,7)
result_gd=result_gd.append({'Degree':7,'Train Error':tr,'Avg Train Error':atr,'Test Error':te,'Avg Test Error':ate,'Min Avg Train Error':mtr,'Min Avg Test error':mte,'W':w[deg]},ignore_index=True)
mse_tr.append(mtr)
mse_tst.append(mte)
degs.append(7)

X_train,y_train,X_test,y_test,N=preprocess_data(data,0,8)
tr,atr,te,ate,mtr,mte,w[8]=grad_desc(X_train,y_train,X_test,y_test,0.001,N,8)
result_gd=result_gd.append({'Degree':8,'Train Error':tr,'Avg Train Error':atr,'Test Error':te,'Avg Test Error':ate,'Min Avg Train Error':mtr,'Min Avg Test error':mte,'W':w[deg]},ignore_index=True)
mse_tr.append(mtr)
mse_tst.append(mte)
degs.append(8)

X_train,y_train,X_test,y_test,N=preprocess_data(data,0,9)
tr,atr,te,ate,mtr,mte,w[9]=grad_desc(X_train,y_train,X_test,y_test,0.0001,N,9)
result_gd=result_gd.append({'Degree':9,'Train Error':tr,'Avg Train Error':atr,'Test Error':te,'Avg Test Error':ate,'Min Avg Train Error':mtr,'Min Avg Test error':mte,'W':w[deg]},ignore_index=True)
mse_tr.append(mtr)
mse_tst.append(mte)
degs.append(9)

plt.plot(degs,mse_tr)
plt.plot(degs,mse_tst)
plt.xticks(np.arange(0.0,10.0,1.0))

result_gd

w1=dict()

result_sgd = pd.DataFrame(columns=['Degree','Train Error','Avg Train Error','Test Error','Avg Test Error','Min Avg Train Error','Min Avg Test error','W'])

for deg in range(10):
  X_train,y_train,X_test,y_test,N=preprocess_data(data,0,deg)
  print("FITTING POLYNOMIAL OF DEGREE : " , deg)
  tr,atr,te,ate,mtr,mte,w1[deg]=sgd(X_train,y_train,X_test,y_test,0.1,N,deg)
  result_sgd=result_sgd.append({'Degree':deg,'Train Error':tr,'Avg Train Error':atr,'Test Error':te,'Avg Test Error':ate,'Min Avg Train Error':mtr,'Min Avg Test error':mte,'W':w[deg]},ignore_index=True)

result_sgd

from mpl_toolkits.mplot3d import Axes3D
X,Y = np.array(data["Strength"]),np.array(data["Temperature"])
fig = plt.figure(figsize=(8,8))
Z = np.array(data["Pressure"])
ax = plt.axes(projection='3d')
ax.scatter(X,Y,Z,marker='x')
ax.set_xlabel('Strength') 
ax.set_ylabel('Temp') 
ax.set_zlabel('Pressure')
plt.title('Plot of the data points in 3D')
plt.show()

def polynomial_regression(data,w,deg=0):
  new_data = pd.DataFrame([])
  pow = []
  for i in range(deg+1):
    for j in range(deg+1):
      if(i+j <= deg):
        pow.append((i,j))
  idx=0
  for (x,y) in pow:
    r=((data["Strength"]**x)*(data["Temperature"]**y))
    new_data.insert(idx,"f"+str(x)+str(y),r,True)
    idx+=1
  
  return np.array(new_data@w)

from matplotlib import cm
for d in range(10):
  data1=data
  data1["Strength"]=(data1["Strength"]-data1["Strength"].min())/(data1["Strength"].max()-data1["Strength"].min())
  data1["Temperature"]=(data1["Temperature"]-data1["Temperature"].min())/(data1["Temperature"].max()-data1["Temperature"].min())

  print("SURFACE PLOT FOR POLYNOMIAL OF DEGREE ",d)
  xsurf , ysurf = np.meshgrid(np.linspace(0.0,1.0,200),np.linspace(0.0,1.0,200))
  val = pd.DataFrame({'Strength':xsurf.ravel(),'Temperature':ysurf.ravel()})
  y_fit = polynomial_regression(val,w[d],d)
  fig = plt.figure(figsize=(8,8))
  ax = fig.add_subplot(111,projection='3d')
  ax.scatter(data1['Strength'],data1['Temperature'],data1["Pressure"],c='red',alpha=0.5)
  ax.plot_surface(xsurf,ysurf,y_fit.reshape(xsurf.shape),color='blue',alpha=0.4)
  ax.set_xlabel('Strength') 
  ax.set_ylabel('Temp') 
  ax.set_zlabel('Pressure')

  plt.show()
  print("==========================================================")

def grad_desc_regularization(X,Y,Xt,Yt,lr,N,deg,type):
  result_reg = pd.DataFrame(columns=['Lambda','Avg Train Error','Avg Test Error','RMSE_Train','RMSE_test'])

  X = np.array(X)
  Y = np.array(Y)
  Xt = np.array(Xt)
  Yt = np.array(Yt)
  rmse_train=[]
  rmse_test = []
  lambdas = np.linspace(0.0,0.001,50)
  for l in lambdas:
    prev=1e10
    W= np.random.random(N)
    for i in range(10000):
      d= ((X@W.T)-Y) 
      dt = ((Xt@W.T)-Yt)
      if((0.5)*(d@d) == math.inf or (0.5)*(d@d) == math.nan):
        break
      if(type==0):
        e = (0.5)*(d@d + l*(sum([abs(wi) for wi in W])))
        et = (0.5)*(dt@dt + l*(sum([abs(wi) for wi in W])))
        sw = np.array([(w/abs(w)) for w in W])
        grad = (X.T@d + (0.5)*(l)*(sw))
      elif(type==1):
        e = (0.5)*(d@d + l*(sum([wi**2 for wi in W])))
        et = (0.5)*(dt@dt + l*(sum([wi**2 for wi in W])))
        grad = (X.T@d + l*W)
    
      W -= lr*(grad/len(X))
      #if(i%50 == 0):
       # print("Lamda: ",l,"||","Epoch = ",i,"|| train_error = ",e/len(X),"||","test_error = ",et/len(Xt),"||",W)
      if(abs(prev-e) <= 5e-5 or math.isnan(e) or math.isnan(et)):
        break
      prev=e

    r2_train = np.sqrt((2*e)/len(X))
    r2_test = np.sqrt((2*et)/len(Xt)) 
    rmse_train.append(r2_train)
    rmse_test.append(r2_test)

    print("Lambda value : " , l)

    print("TRAIN ERROR : " , e)
    print("AVG. TRAIN ERROR : " , e/len(X))
    print("TEST ERROR : " , et)
    print("AVG. TEST ERROR : " , et/len(Xt))
    

    print("==================================================================")
    result_reg=result_reg.append({'Lambda':l,'Avg Train Error':e/len(X),'Avg Test Error':et/len(Xt),'RMSE_Train':r2_train,'RMSE_test':r2_test},ignore_index=True)

 
  
  
  plt.plot(np.log(lambdas),rmse_train)
  plt.plot(np.log(lambdas),rmse_test)

  
  return W,lambdas,result_reg

# Gradient Descent with lasso regression
X_train,y_train,X_test,y_test,N = preprocess_data(data,0,9)
w,l,rt=grad_desc_regularization(X_train,y_train,X_test,y_test,0.05,N,9,0)

rt

# Gradient Descent with Ridge Regression
w,l,rt=grad_desc_regularization(X_train,y_train,X_test,y_test,0.05,N,9,1)

rt

def sgd_regularization(X,Y,Xt,Yt,lr,N,deg,type=0):
  result_reg = pd.DataFrame(columns=['Lambda','Avg Train Error','Avg Test Error','RMSE_Train','RMSE_test'])
  X = np.array(X)
  Y = np.array(Y)
  Xt = np.array(Xt)
  Yt = np.array(Yt)
  rmse_train=[]
  rmse_test = []
  lambdas = np.linspace(0.0,0.001,20)
  for l in lambdas:
    prev=1e10
    W= np.random.random(N)
    for i in range(500):
      d= ((X@W.T)-Y) 
      dt = ((Xt@W.T)-Yt)
      if((0.5)*(d@d) == math.inf or (0.5)*(d@d) == math.nan):
        break
      if(type==0):
        e = (0.5)*(d@d + l*(sum([abs(wi) for wi in W])))
        et = (0.5)*(dt@dt + l*(sum([abs(wi) for wi in W])))
        
      elif(type==1):
        e = (0.5)*(d@d + l*(sum([wi**2 for wi in W])))
        et = (0.5)*(dt@dt + l*(sum([wi**2 for wi in W])))
      
      for id in range(len(X)):
        if(type==0):
          sw = np.array([(w/abs(w)) for w in W])
          W -= (lr)*(((X[id]@W.T)-Y[id])*X[id] + l*W)
        elif(type==1):
          W -= (lr)*(((X[id]@W.T)-Y[id])*X[id] + l*W)



      #if(i%50 == 0):
        #print("Lamda: ",l,"||","Epoch = ",i,"|| train_error = ",e/len(X),"||","test_error = ",et/len(Xt),"||",W)
      if(abs(prev-e) <= 5e-5 or math.isnan(e) or math.isnan(et)):
        break
      prev=e

    r2_train = np.sqrt((2*e)/len(X))
    r2_test = np.sqrt((2*et)/len(Xt)) 
    rmse_train.append(r2_train)
    rmse_test.append(r2_test)

    print("Lambda value : " , l)

    print("TRAIN ERROR : " , e)
    print("AVG. TRAIN ERROR : " , e/len(X))
    print("TEST ERROR : " , et)
    print("AVG. TEST ERROR : " , et/len(Xt))

    print("==================================================================")
    result_reg=result_reg.append({'Lambda':l,'Avg Train Error':e/len(X),'Avg Test Error':et/len(Xt),'RMSE_Train':r2_train,'RMSE_test':r2_test},ignore_index=True)

  
 

  
  plt.plot(np.log(lambdas),rmse_train)
  plt.plot(np.log(lambdas),rmse_test)

  
  return W,lambdas,result_reg

# SGD with lasso regression
X_train,y_train,X_test,y_test,N = preprocess_data(data,0,9)
w,l,rt=sgd_regularization(X_train,y_train,X_test,y_test,0.05,N,9,0)

rt

# SGD with ridge regression
w,l,rt=sgd_regularization(X_train,y_train,X_test,y_test,0.05,N,9,1)

rt